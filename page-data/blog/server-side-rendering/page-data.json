{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/server-side-rendering","result":{"data":{"markdownRemark":{"html":"<p><strong><em>A brief overview of the benefits and drawbacks of server side rendering.</em></strong></p>\n<p>Not too long ago, when Ruby on Rails was the <em>de facto</em> framework for building on the web, server side rendering (SSR) was the default. Web apps served HTML, CSS, and JavaScript files in response to HTTP calls to the server. Often, the server would dynamically create these files using Ruby (or some other programming language), and a connection to a database. Further more, because as programmers we value the separation of concerns, we subdivided our HTML into smaller components—\"partials\" in Rails. These pieces, along with content from our database, were assembled on the server and passed on to the browser for interaction by the end user. Interactions with our web apps were then passed back to the server by a range of HTTP verbs, which in turn handled computation and database modifications, and responded with updated content.</p>\n<p>The above pattern is still widely in use across the web today. However, with the explosion in popularity of front-end frameworks, <strong>more and more of our web content is being assembled within the browser itself by JavaScript code.</strong> With this client-side-rendering pattern, the server initially serves a minimal HTML file, followed by waves of JavaScript code that fetch the necessary data and compose the remainder of our web pages content. JavaScript is no longer a language merely used for adding mild interactivity to web pages. JavaScript is <strong>the</strong> assembly language orchestrating and building much of the modern web. In fact, even <a href=\"https://webassembly.org/\">Web Assembly</a> must be loaded and compiled by the JavaScript engine in modern browsers.</p>\n<p>Client-side-rendering has proliferated across the web, and for good reason. <strong><em>Assuming the end user has a performant device and a strong internet connection and the server and data center are modern</em></strong>, they will be delighted by an impressively fast and highly interactive experience that has become the expected behavior for modern web apps. While these assumptions are becoming increasingly realized, most of the world still interfaces with the web on low-to-mid-end mobile devices. It is therefore important that we design our modern web apps to provide decent user experiences to this majority.</p>\n<p>Server-side-rendering has two important benefits:</p>\n<ol>\n<li><strong>Performance</strong>: SSR helps decrease \"time to visible\" of web pages. There are fewer roundtrips to the server involved, and when coupled with hot servers (cached content), users will see your content faster than with CSR. This is especially true when users are on low end mobile devices, because servers are typically much faster. Also, because HTML is a streaming protocol, it can be loaded as it arrives by the browser. This is in contrast to JavaScript, which requires entire files to be loaded before execution. Essential JS can be inlined for basic page interactivity initially.</li>\n<li><strong>Search Engine Optimization:</strong> If you've ever written (or tried to write) a web scraper/crawler for a client-side-rendered page, you understand. Although Google's crawlers are now capable or efficiently parsing and indexing content rendered by client-side JavaScript, not all search engines have the same abilities. Crawlers are better at reading HTML rendered by the server than handling all of the JS that pieces together many pages. Additionally, your content will be optimized for social media thumb-nailing, with linked pages (on Facebook, Twitter, etc.) displaying page title, description, and image.</li>\n</ol>\n<p>Tom Dale, one of the creators of Ember.js, summed it up by writing,</p>\n<blockquote>\n<p>The performance of your server is much more predictable, and more easily upgraded, than the many, many different device configurations of your users. Server-rendering is important to ensure that users who are not on the latest-and-greatest can see your content immediately when they click a link.</p>\n</blockquote>\n<p>Given these advantages, many web application developers are returning to the time tested practice of server-side-rendering. Yet this time around, the approach is often quite different to the glory days of simple model-view-controller based Rails applications. Nowadays, we can utilize <strong>isomorphic JavaScript</strong> to enjoy the user experience benefits of client-side-rendering in conjunction with the predictability and universal reach of server-side rendered content.</p>\n<p><strong>Isomorphic JavaScript (or Universal JS)</strong> is JavaScript that can run on both the client and the server. Many modern front-end frameworks utilize isomorphic code. React allows you to implement basic SSR fairly easily. In fact, this blog was built with Gatsby, a React \"framework\" for building static sites with React and server side rendering. Similar to Gatsby's code under the hood, we will use the hydrate method to signal to the renderer that we are rehydrating our app after an initial server side render.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// index.js</span>\n\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">hydrate</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"root\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Image we have a Koa instance setup to serve our fully rendered content. Here, we will import our app component from the client directory and import the ReactDOMServer to use its</p>\n<p><code class=\"language-text\">renderToString</code> method for serving our app as a static HTML string.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// server.js</span>\n\nrouter<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/*\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx<span class=\"token punctuation\">,</span> next</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> app <span class=\"token operator\">=</span> ReactDOMServer<span class=\"token punctuation\">.</span><span class=\"token function\">renderToString</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> indexFile <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./build/index.html\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>indexFile<span class=\"token punctuation\">,</span> <span class=\"token string\">\"utf8\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> data</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bummer:\"</span><span class=\"token punctuation\">,</span> err<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">status</span><span class=\"token punctuation\">(</span><span class=\"token number\">500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Please try again.\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> ctx<span class=\"token punctuation\">.</span><span class=\"token function\">send</span><span class=\"token punctuation\">(</span>\n      data<span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token string\">'&lt;div id=\"root\">&lt;/div>'</span><span class=\"token punctuation\">,</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">&lt;div id=\"root\"></span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>app<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">&lt;/div></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>While this is a trivial example, it is illustrative of the basics of implementing SSR with React. Covering routing and data fetching with SSR in React will require a separate blog post. There are many tools and frameworks that help abstract away the complexities of SSR and maintain the benefits of CSR. With React, the go-to solution is <a href=\"https://nextjs.org/\">Next.js</a></p>\n<p>Before concluding, I will briefly touch on some of the challenges, both inherent and technical, that arise with SSR. Firstly, with isomorphic JavaScript, you have to be careful with recycling code that references the browser DOM for use on the server. You can use a simple IF check:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> window <span class=\"token operator\">==</span> <span class=\"token string\">\"undefined\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//run serverside code</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Furthermore, you can set up some ESLint rules that prevent you from calling on the DOM in server side code.</p>\n<p>Inherently, with SSR, your pages time to interactive will not improve much compared to CSR. However, you should implement <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement\">progressive enhancement</a> and hydrate your page incrementally. Another solution is to use different root nodes for above the fold and below the fold content. In other words, split your frontend between priority content that is most important, and that which can wait to be loaded.</p>\n<p>Dan Shappir, the Performance Tech Lead at Wix has an <a href=\"https://www.youtube.com/watch?v=O1wBZviW7yI\">excellent talk</a> on this topic and also went into more detail on <a href=\"https://devchat.tv/js-jabber/jsj-371-the-benefits-and-challenges-of-server-side-rendering-ssr-with-dan-shappir/\">this podcast</a>.</p>\n<p>In looking forward, I would argue that many of the benefits of server side rendering will ultimately be outweighed by the performance and user experience benefits of client side rending—especially as performant devices and high speed internet become more widely available. The future of the web is unclear, but one thing is for certain...technologies will continue to improve and adapt to changing socioeconomic conditions. Hopefully the technologies that gain wide adoption will foster the human in us, and provide for a prosperous and inclusive future.</p>","excerpt":"A brief overview of the benefits and drawbacks of server side rendering. Not too long ago, when Ruby on Rails was the de facto framework for…","frontmatter":{"date":"August 13, 2019","slug":"/blog/server-side-rendering","title":"Is Server Side Rendering Back in Vogue?","featuredImage":null}}},"pageContext":{"slug":"/blog/server-side-rendering"}},"staticQueryHashes":["2052298874"]}